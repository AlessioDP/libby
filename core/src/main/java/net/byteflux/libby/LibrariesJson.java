package net.byteflux.libby;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.regex.Pattern;

/**
 * A representation of the libraries.json generated by
 *  <a href="https://github.com/Minecrell/plugin-yml">Minecrell's plugin-yml gradle plugin</a>. <br>
 * The instance of this class could convert the loaded JSON into {@link Library} instances,
 *  and insert the parsed dependencies to the provided {@link LibraryManager}.
 *
 * @author SNWCreations
 */
public class LibrariesJson {
    private static final Pattern QUOTED_DOT;

    static {
        QUOTED_DOT = Pattern.compile(Pattern.quote("."));
    }

    private final Map<String, String> repositories;
    private final List<String> libraries;

    public LibrariesJson(Map<String, String> repositories, List<String> libraries) {
        this.repositories = repositories;
        this.libraries = libraries;
    }

    /**
     * Parse the library notations with default settings defined by
     *  the {@link Library.Builder}.
     *
     * @return The parsed {@link Library} instances.
     * @see #toLibraries(Consumer)
     */
    public List<Library> toLibraries() {
        return toLibraries(unused -> {});
    }

    /**
     * Convert the library notations defined by this instance to {@link Library} instances.
     *
     * @param postBuild Called before building the final {@link Library} instance.
     *                  We could do more modification there to customize the result.
     *                  For example, we could determine if the library is loaded in an
     *                  isolated class loader by calling
     *                  {@link Library.Builder#isolatedLoad(boolean)} in the callback.
     * @return The parsed {@link Library} instances.
     */
    public List<Library> toLibraries(Consumer<Library.Builder> postBuild) {
        final List<Library> result = new ArrayList<>();
        for (String notation : libraries) {
            final Library.Builder builder = Library.builder();
            // Dependency notation format: https://stackoverflow.com/q/28713154
            final String[] split = QUOTED_DOT.split(notation);
            final String group = split[0];
            final String artifact = split[1];
            final String version = split[2];
            builder.groupId(group);
            builder.artifactId(artifact);
            builder.version(version);
            if (split.length > 3) { // we have classifier!
                final String finalClassifier;
                final String classifier = split[3];
                if (classifier.contains("@")) { // extension detected
                    final String[] splitClassifier = QUOTED_DOT.split(classifier);
                    finalClassifier = splitClassifier[0];
                    // extension is dropped there as we don't need it, we just need JAR
                    // and this should never happen
                } else {
                    finalClassifier = classifier;
                }
                builder.classifier(finalClassifier);
            }
            // insert repository urls to the built library object
            for (String repoUrl : repositories.values()) {
                builder.repository(repoUrl);
            }
            postBuild.accept(builder); // let callback run
            final Library builtLibrary = builder.build();
            result.add(builtLibrary);
        }
        return result;
    }

    /**
     * Let the provided {@link LibraryManager} load the libraries defined in this instance.
     *
     * @param loader The {@link LibraryManager} which will be used to load libraries.
     */
    public void load(LibraryManager loader) {
        final List<Library> parsedLibraries = toLibraries();
        for (Library library : parsedLibraries) {
            loader.loadLibrary(library);
        }
    }
}
